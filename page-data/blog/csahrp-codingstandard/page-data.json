{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/csahrp-codingstandard",
    "result": {"data":{"post":{"slug":"/blog/csahrp-codingstandard","title":"C# coding Standard","date":"21.06.2023","tags":[{"name":"Code management and collaboration","slug":"code-management-and-collaboration"}],"description":"some rules that I found useful when doing C# programming","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C# coding Standard\",\n  \"description\": \"some rules that I found useful when doing C# programming\",\n  \"date\": \"2023-06-21T00:00:00.000Z\",\n  \"slug\": \"/blog/csahrp-codingstandard\",\n  \"tags\": [\"Code management and collaboration\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Here is something I found useful while collaborate with others which creates easy-to-read, high quality codes.\"), mdx(\"h2\", null, \"Classes & Interfaces\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Written in \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PascalCase\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If it's a class that interacts with other classes, use names ending in -er (2)\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"SwitchButton\\nButtonSwitcher\\n\")), mdx(\"h2\", null, \"Methods\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Written in \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PascalCase\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Needs to start with a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"verb\"), \" e.g. Do, Change, Swap, Process\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"DoSomething()\\n\")), mdx(\"h2\", null, \"Fields\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Public fields are written in \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PascalCase\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Private and protected are written in \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"camelCase\"), \" with m\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \" before them (\", \"_\", \" is also ok, but if you consider writting in C++ as well, m\"), \" is a better practice, because C++ don't accept such typing)\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyClass {\\n     public int PublicField;\\n    private int m_privateField;\\n    protected int m_protectedField;\\n}\\n\")), mdx(\"h2\", null, \"Parameters\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parameters are written in \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"camelCase\"))), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"void DoSomething(Vector3 location)\\n\")), mdx(\"h2\", null, \"Constants\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Are written with capital letters, separated by underscore\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private const float FADE_EFFECT_MINIMUM_DISTANCE = 0.075f;\\n\")), mdx(\"h1\", null, \"Declarations\"), mdx(\"h2\", null, \"Access Level Modifiers\"), mdx(\"p\", null, \"Access level modifiers should be explicitly defined for classes, methods and member variables (public, private, protected).\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \" this is usually only an issue for the private modifier, since that field can be omitted.\"), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private void Update() {\\n}\\n\")), mdx(\"h2\", null, \"Fields & Variables\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Prefer single declaration per line, sometimes logically grouping fields can be useful but this should be the exception\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Usually bad\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"string username, twitterHandle;\\n\")), mdx(\"p\", null, \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Usually good\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"string username;\\nstring twitterHandle;\\n\")), mdx(\"p\", null, \"Creating a Serializable class to group variables in logic chunks can be useful to reduce clutter in inspector and logically group sets of variables as one unit.\"), mdx(\"h2\", null, \"Events\"), mdx(\"p\", null, \"Name events so it's clear when they are invoked: OnTargetReached, OnObjectRotated, OnSessionCompleted.\"), mdx(\"p\", null, \"Notice how it's often useful to name events in the past tense to show exactly when the event is invoked.\"), mdx(\"h2\", null, \"Classes\"), mdx(\"p\", null, \"Exactly one class per source file, although inner classes are encouraged where scoping is appropriate.\"), mdx(\"h2\", null, \"Interfaces\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All interfaces should be prefaced with the letter I\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bad\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"RadialSlider\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Good\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"IRadialSlider\\n\")), mdx(\"h1\", null, \"Spacing\"), mdx(\"p\", null, \"Spacing is especially important in the code, as the code needs to be easily readable for all team members.\"), mdx(\"h2\", null, \"Line Length\"), mdx(\"p\", null, \"Lines should be no longer than 130 characters long.\"), mdx(\"h2\", null, \"Vertical Spacing\"), mdx(\"p\", null, \"Try to separate variable declaration, method calling and other functionalities in groups inside the same method. If there are many groups, probably they need to be split up in different methods.\"), mdx(\"h1\", null, \"Brace Style\", \" \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Good\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"class ABC\\n{\\n    void doSomething()\\n    {\\n    }\\n }\\n\")), mdx(\"p\", null, \"Since this is the brace style in most C# projects and also recommended in Microsoft's own code convention guide.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bad\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"class ABC {\\n  void DoSomething() {\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Switch Statements\")), mdx(\"p\", null, \"Try to use the pattern match switch when possible, since it reduces boilerplate and prevents common pitfalls of regular switches like code execution falling through one branch into the next.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"command switch\\n{\\n    \\\"SystemTest\\\" => RunDiagnostics(),\\n    \\\"Start\\\" => StartSystem(),\\n    \\\"Stop\\\" => StopSystem(),\\n    \\\"Reset\\\" => ResetToReady(),\\n    _ => throw new ArgumentException(\\\"Invalid string value for command\\\", nameof(command)),\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"switch (something)\\n{\\n  case A:\\n    break;\\n  case B:\\n    break;\\n}\\n\")), mdx(\"h1\", null, \"Code Structure\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"General\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try to separate different functionalities with return\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try to group different functionalities together. E.g. transforms (position, rotation);\", \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try to early exit at top of the function when conditions required for the function to operate are not met\")), mdx(\"h2\", null, \"Example\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Good\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private float DivideNumbers(float a, float b)\\n{\\n    if (b == 0) { return 0; }\\n    return a / b;\\n}\\n\")), mdx(\"p\", null, \"Bad\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private float DivideNumbers(float a, float b)\\n{\\n    if (b != 0)\\n    {\\n        return a / b;\\n    }\\n    \\n    return 0;\\n}\\n\")), mdx(\"p\", null, \"By using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"return\"), \" statements when the code needs to stop, we can prevent right code indentation.\"), mdx(\"h2\", null, \"Important notes\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Public / Private / HiddenInInspector\")), mdx(\"p\", null, \"In some cases, we might need to expose public variables from the class. Though, we don't want to provide them visibility in the inspector (because this might create confusion such as \\\"should I put something in this empty field?\\\"). In this case, there are 2 ways of solving it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[HideInInspector]\\npublic int TheValue;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public int TheValue { get; set; }\\npublic int TheOtherValue { get; private set; }\\n\")), mdx(\"p\", null, \"The 2nd is preferred. In special cases like this, these two should be kept together and placed with public variables. If you only want to expose a getter the 3rd option is the best.\"), mdx(\"p\", null, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Warning\"), \": when serializing JSON classes, some variable declarations do not work, essentially you should think of properties more as methods than variables.\"), mdx(\"p\", null, \"Works:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public int Number;\\n\")), mdx(\"p\", null, \"Does not serialize:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public int Number { get; set; }\\n\")), mdx(\"h2\", null, \"Attributes\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"General\")), mdx(\"p\", null, \"Since it's better for cohesiveness and structure if all attributes follow the same convention, opt to put all attributes above the code they target - even if it's a class or a variable. This way there's less clutter in diffs if someone needs to add more attributes, and we don't have to worry about readability or total line length when adding attributes.\\\\\\n\\\\\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bad\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[SerializeField, HideInInspector] private bool _myField;\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Good\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[CustomPropertyDrawer(typeof(MyClass)]\\npublic class MyClassPropertyDrawer : PropertyDrawer\\n\\n[SerializeField, HideInInspector]\\nprivate bool _myField;\\n\")), mdx(\"h2\", null, \"Class Structure\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/// Description for the class\\nclass ExampleClass\\n{\\n\\n    // Constants.\\n    private const float TIME_OF_DELAY_IN_SECONDS = 0.5f;\\n\\n    // Child classes.\\n    private class KeyPairValue\\n    {\\n        public string Key;\\n        public string Value;\\n    }\\n\\n    // Child enums.\\n    private enum OptionsEnum\\n    {\\n        OptionOne,\\n        OptionTwo,\\n        OptionThree\\n    }\\n\\n    // Public variables.\\n    public int Number;\\n    public int Count;\\n\\n    // Private/protected, which are exposed into the editor.\\n    [SerializeField]\\n    private float _secondsToStart;\\n    [SerializeField]\\n    protected string _debugText;\\n\\n    // Private/protected, not exposed in the editor.\\n    private string _translationForName;\\n\\n    // Unity default methods.\\n    private void Awake()\\n    {\\n    }\\n\\n    private void OnEnable()\\n    {\\n    }\\n\\n    // Public custom methods.\\n    public void SetData(string newData)\\n    {\\n    }\\n\\n    // Private/protected methods.\\n    private void CalculateRange()\\n    {\\n    }\\n\\n    // Callbacks.\\n    private void OnButtonPressed()\\n    {\\n    }\\n\\n    private void OnEventTriggered()\\n    {\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": there are exceptions, for example, it is more important that the initialization sequence is one after the other even if some methods are private.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Here is something I found useful while collaborate with others which creates easy-to-read, high quality codes. Classes & Interfaces Writtenâ€¦","timeToRead":2,"banner":null}},"pageContext":{"slug":"/blog/csahrp-codingstandard","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}