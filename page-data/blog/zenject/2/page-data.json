{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/zenject/2",
    "result": {"data":{"post":{"slug":"/blog/zenject/2","title":"DI in Zenject 2(Non-mono, SignalBus and Factory)","date":"20.07.2022","tags":[{"name":"Unity development","slug":"unity-development"},{"name":"Design Pattern","slug":"design-pattern"}],"description":"Zenject discussion","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DI in Zenject 2(Non-mono, SignalBus and Factory)\",\n  \"description\": \"Zenject discussion\",\n  \"date\": \"2022-07-20T00:00:00.000Z\",\n  \"slug\": \"/blog/zenject/2\",\n  \"tags\": [\"Unity development\", \"Design Pattern\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"1. Non-mono\"), mdx(\"p\", null, \"In some cases, it is preferable to avoid the extra weight of MonoBehaviours in favor of just normal C# classes. Zenject allows you to do this much more easily by providing interfaces that mirror functionality that you would normally need to use a MonoBehaviour for. Then you can use the Unity lifecycle without the need of attaching it to the scene. For example, the BlueTooth service start at the initialization of the game and stops when the game stop, but it doesn\\u2019t make sense to attach to the scene to fulfill the function.\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/zenject-2/NonMonoInterfaces.png\",\n    \"width\": \"100%\",\n    \"alt\": \"Non-MonoInterfaces\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 1 Non-MonoInterfaces\\n  \\t\")), mdx(\"p\", null, \"To use the interfaces above, you have to bind multiple interfaces to a single instance:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.Bind(typeof(Foo), typeof(IInitializable), typeof(IDisposable)).To<Logger>().AsSingle();\\n\")), mdx(\"p\", null, \"It can be made simpler by this: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.Bind(new[] { typeof(Foo) }.Concat(typeof(Foo).GetInterfaces())).To<Foo>().AsSingle();\\n\")), mdx(\"p\", null, \"This pattern is useful enough that Zenject includes a custom bind method for it. The above code is equivalent to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.BindInterfacesAndSelfTo<Foo>().AsSingle();\\n\\nContainer.BindInterfacesTo<Foo>().AsSingle();\\n\")), mdx(\"h1\", null, \"2. Factory\"), mdx(\"p\", null, \"When create new objects dynamically, using the instantiate method won\\u2019t automatically bind the instance to the container, and it\\u2019s not injected to the container. The factory is there to solve this problem.\"), mdx(\"p\", null, \"The following method will get a null exception for _player, because the Player instance was never injected to the SimpleEnemy Class\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class SimpleEnemy:MonoBehaviour\\n    {\\n        private Player _player;\\n\\n        [Inject]\\n        void Constructor(Player player)\\n        {\\n            Debug.Log(\\\"Run constructor in mono\\\");\\n            _player = player;\\n        }\\n\\n        private void Update()\\n        {\\n            if (Input.GetKeyDown(KeyCode.P))\\n            {\\n                //Error: cannot find _player instance.\\n                Debug.Log(\\\"Enemy \\\" +this.GetHashCode() +\\\"with Player \\\"+_player.GetHashCode());\\n            }\\n        }\\n    }\\n\")), mdx(\"p\", null, \"By implementing a Factory class which is derived from PlaceholderFactory,  the SimpleEnemy class can be instantiate by a SimpleEnemy.Factory.Create() method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"//without parameter\\npublic class SimpleEnemy:MonoBehaviour\\n    {\\n        private Player _player;\\n\\n        [Inject]\\n        void Constructor(Player player)\\n        {\\n            Debug.Log(\\\"Run constructor in mono\\\");\\n            _player = player;\\n        }\\n\\n        private void Update()\\n        {\\n            if (Input.GetKeyDown(KeyCode.P))\\n            {\\n                Debug.Log(\\\"Enemy \\\" +this.GetHashCode() +\\\"with Player \\\"+_player.GetHashCode());\\n            }\\n        }\\n\\n        public class Factory : PlaceholderFactory<SimpleEnemy>{ }\\n    }\\n\\npublic class GameLogic : MonoBehaviour\\n    {\\n        private Player _player;\\n        private SimpleEnemy.Factory _simpleEnemyFactory;\\n\\n        [Inject]\\n        private void Constructor(Player player,SimpleEnemy.Factory simpleEnemyFactory)\\n        {\\n            _player = player;\\n            _simpleEnemyFactory = simpleEnemyFactory;\\n        }\\n        public void InstantiateEnemy()\\n        {\\n           SimpleEnemy enemy = _simpleEnemyFactory.Create();\\n            Debug.Log(\\\"Create enemy\\\" + enemy.name);\\n        }\\n    }\\n\\npublic class GameInstaller : MonoInstaller\\n    {\\n        [SerializeField]\\n        private SimpleEnemy simpleEnemyPrefab;\\n        public override void InstallBindings()\\n        {\\n            Container.Bind<Player>().AsSingle();\\n            //note that you have to use FromComponentInNewPrefab() or similar methods to instantiate a Mono Prefab\\n            Container.BindFactory<SimpleEnemy, SimpleEnemy.Factory>().FromComponentInNewPrefab(simpleEnemyPrefab).AsSingle();\\n        }\\n    }\\n\\npublic class Player\\n    {\\n        Player()\\n        {\\n            Debug.Log(\\\"Player spawned\\\" + this.GetHashCode());\\n        }\\n    }\\n\")), mdx(\"p\", null, \"You can also configure parameters when call the Create() function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Enemy\\n{\\n    readonly Player _player;\\n    readonly float _speed;\\n\\n    public Enemy(float speed, Player player)\\n    {\\n        _player = player;\\n        _speed = speed;\\n    }\\n\\n    public class Factory : PlaceholderFactory<float, Enemy>\\n    {\\n    }\\n}\\n\\npublic class EnemySpawner : ITickable\\n{\\n    readonly Enemy.Factory _enemyFactory;\\n\\n    public EnemySpawner(Enemy.Factory enemyFactory)\\n    {\\n        _enemyFactory = enemyFactory;\\n    }\\n\\n    public void Tick()\\n    {\\n        if (ShouldSpawnNewEnemy())\\n        {\\n            var newSpeed = Random.Range(MIN_ENEMY_SPEED, MAX_ENEMY_SPEED);\\n            var enemy = _enemyFactory.Create(newSpeed);\\n            // ...\\n        }\\n    }\\n}\\n\\npublic class TestInstaller : MonoInstaller\\n{\\n    public override void InstallBindings()\\n    {\\n        Container.BindInterfacesTo<EnemySpawner>().AsSingle();\\n        Container.Bind<Player>().AsSingle();\\n        Container.BindFactory<float, Enemy, Enemy.Factory>();\\n    }\\n}\\n\")), mdx(\"p\", null, \"****  The Factory pattern in Zenject can also be used for controlling a State-Machine. You can find the example of a State-Machine for SpaceShip in the First Zenject Sample Project.\"), mdx(\"h1\", null, \"3. Signal Bus\"), mdx(\"h2\", null, \"3.1 \", mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"Motivation / Theory\")), mdx(\"p\", null, \"Given two classes A and B that need to communicate, your options are usually:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Directly call a method on B from A. In this case, A is strongly coupled with B.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Inverse the dependency by having B observe an event on A. In this case, B is strongly coupled with A\")), mdx(\"p\", null, \"As a third option, in some cases it might actually be better for neither one to know about the other. This way your code is kept as loosely coupled as possible. You can achieve this by having A and B interact with an intermediary object (in this case, zenject signals) instead of directly with each other.\"), mdx(\"p\", null, \"Note also that while the result will be more loosely coupled, this isn't always going to be better. Signals can be misused just like any programming pattern, so you have to consider each case for whether it's a good candidate for them or not.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Greeter : IInitializable, IDisposable\\n{\\n    readonly SignalBus _signalBus;\\n\\n    public Greeter(SignalBus signalBus)\\n    {\\n        _signalBus = signalBus;\\n    }\\n\\n    public void Initialize()\\n    {\\n        _signalBus.Subscribe<UserJoinedSignal>(OnUserJoined);\\n    }\\n\\n    public void Dispose()\\n    {\\n        _signalBus.Unsubscribe<UserJoinedSignal>(OnUserJoined);\\n    }\\n\\n    void OnUserJoined(UserJoinedSignal args)\\n    {\\n        SayHello(args.Username);\\n    }\\n\\n    public void SayHello(string userName)\\n    {\\n        Debug.Log(\\\"Hello \\\" + userName + \\\"!\\\");\\n    }\\n}\\n\\npublic class GameInstaller : MonoInstaller<GameInstaller>\\n{\\n    public override void InstallBindings()\\n    {\\n        SignalBusInstaller.Install(Container);\\n\\n        Container.DeclareSignal<UserJoinedSignal>();\\n\\n        // Here, we can get away with just binding the interfaces since they don't refer\\n        // to each other\\n        Container.BindInterfacesTo<Greeter>().AsSingle();\\n        Container.BindInterfacesTo<GameInitializer>().AsSingle();\\n    }\\n}\\n\")), mdx(\"p\", null, \"The signal is a class, Any parameters passed along with the signal should be added as public members or properties. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class WeaponEquippedSignal\\n{\\n    public Player Player;\\n    public IWeapon Weapon;\\n}\\n\")), mdx(\"p\", null, \"After we have created our signal class we just need to declare it in an installer somewhere:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.DeclareSignal<PlayerDiedSignal>();\\n\")), mdx(\"h2\", null, \"3.2 \", mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"Signal Firing\")), mdx(\"p\", null, \"To fire the signal, you add a reference to the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SignalBus\"), \"\\xA0class, and then call the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fire\"), \"\\xA0method like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class UserJoinedSignal\\n{\\n}\\n\\npublic class UserManager\\n{\\n    readonly SignalBus _signalBus;\\n\\n    public UserManager(SignalBus signalBus)\\n    {\\n        _signalBus = signalBus;\\n    }\\n\\n    public void DoSomething()\\n    {\\n        _signalBus.Fire<UserJoinedSignal>();\\n    }\\n}\\n\")), mdx(\"p\", null, \"Or, if the signal has parameters then you will want to create a new instance of it, like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class UserJoinedSignal\\n{\\n    public string Username;\\n}\\n\\npublic class UserManager\\n{\\n    readonly SignalBus _signalBus;\\n\\n    public UserManager(SignalBus signalBus)\\n    {\\n        _signalBus = signalBus;\\n    }\\n\\n    public void DoSomething()\\n    {\\n        _signalBus.Fire(new UserJoinedSignal() { Username = \\\"Bob\\\" });\\n    }\\n}\\n\")), mdx(\"p\", null, \"When\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fire()\"), \"\\xA0is called, SignalBus expects the signal to be declared and exception will be thrown if the signal is not declared. If you want to call\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fire()\"), \"\\xA0regardless of the signal declaration, use\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TryFire()\"), \"\\xA0method instead that ignores undeclared signals. You can use\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TryFire()\"), \"\\xA0looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class UserJoinedSignal\\n{\\n}\\n\\npublic class UserManager\\n{\\n    readonly SignalBus _signalBus;\\n\\n    public UserManager(SignalBus signalBus)\\n    {\\n        _signalBus = signalBus;\\n    }\\n\\n    public void DoSomething()\\n    {\\n        // Generic version\\n        _signalBus.TryFire<UserJoinedSignal>(); // Nothing happens if UserJoinedSignal is NOT declared\\n\\n        // Non-Generic version\\n        _signalBus.TryFire(new UserJoinedSignal()); // Nothing happens if UserJoinedSignal is NOT declared\\n    }\\n}\\n\")), mdx(\"p\", null, \"As a result of this, signals are not enabled automatically, so you have to explicitly install them yourself by calling\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SignalBusInstaller.Install(Container)\"), \"\\n\\xA0in one of your installers.\"), mdx(\"h2\", null, \"3.3 Abstract signal\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Example\\n{\\nSignalBus signalBus;\\npublic Example(Signalbus signalBus) => this.signalBus = signalBus;\\n\\npublic void CheckpointReached() => signalBus.AbstractFire<SignalCheckpointReached>();\\n\\npublic void CompleteLevel() => signalBus.AbstractFire<SignalLevelCompleted>();\\n}\\n\\npublic class SaveGameSystem\\n{\\npublic SaveGameSystem(SignalBus signalBus)\\n{\\nsignalBus.Subscribe<ISignalGameSaver>(x => SaveGame());\\n}\\n\\nvoid SaveGame() { /*Saves the game*/ }\\n}\\n\\n//in your installer\\nContainer.DeclareSignalWithInterfaces<SignalLevelCompleted>();\\nContainer.DeclareSignalWithInterfaces<SignalCheckpointReached>();\\n\\n//your signal types\\npublic struct SignalCheckpointReached : ISignalGameSaver{}\\npublic struct SignalLevelCompleted : ISignalGameSaver{}\\n\\npublic interface ISignalGameSaver{}\\n\")), mdx(\"h2\", null, \"3.4 \", mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"When To Use Signals\")), mdx(\"p\", null, \"Signals are most appropriate as a communication mechanism when:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There might be multiple interested receivers listening to the signal\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The sender doesn't need to get a result back from the receiver\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The sender doesn't even really care if it gets received. In other words, the sender should not rely on some state changing when the signal is called for subsequent sender logic to work correctly. Ideally signals can be thought as \\\"fire and forget\\\" events\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The sender triggers the signal infrequently or at unpredictable times\")), mdx(\"p\", null, \"Note: You can do this in Zenject out-of-the-box by executing the menu item\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Edit -> Zenject -> Validate Current Scene\"), \"\\xA0or simply hitting\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SHIFT+ALT+V\"), \"\\xA0with the scenes open that you want to validate.\"), mdx(\"h1\", null, \"4.Example1\"), mdx(\"p\", null, \"After learning basic concepts about injection, binding, Installer, and other topics about the non-mono interface, Factory and Signal Bus, it\\u2019s sufficient to understand the first Sample that was given in the Zenject package.\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/zenject-2/GameInstaller.png\",\n    \"width\": \"100%\",\n    \"alt\": \"The architecture of Sample Game 1 in Zenject\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 2 The architecture of Sample Game 1 in Zenject\\n  \\t\")), mdx(\"h1\", null, \"Reference\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject/blob/master/Documentation/Factories.md\"\n  }, \"https://github.com/modesttree/Zenject/blob/master/Documentation/Factories.md\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject\"\n  }, \"https://github.com/modesttree/Zenject\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://erdiizgi.com/dependency-injection-unity-zenject/\"\n  }, \"https://erdiizgi.com/dependency-injection-unity-zenject/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=6tn8pMQuxEk&list=PLKERDLXpXl_jNJPY2czQcfPXW4BJaGZc_&index=2\"\n  }, \"https://www.youtube.com/watch?v=6tn8pMQuxEk&list=PLKERDLXpXl\", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"jNJPY2czQcfPXW4BJaGZc\"), \"&index=2\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.csdn.net/unity3d_xyz/category_8487718.html\"\n  }, \"https://blog.csdn.net/unity3d_xyz/category_8487718.html\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject/blob/master/Documentation/Signals.md\"\n  }, \"https://github.com/modesttree/Zenject/blob/master/Documentation/Signals.md\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"1. Non-mono In some cases, it is preferable to avoid the extra weight of MonoBehaviours in favor of just normal C# classes. Zenject allowsâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/blog/zenject/2","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}